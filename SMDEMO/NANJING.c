/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.26                          *
*        Compiled Aug  8 2014, 14:49:54                              *
*        (c) 2013 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/


///加了 定时器中断 产生搅拌，将不要的文件删除了

///新版 I/O口修改；存储斜率值；满足要求

//加了自动校准，在中断5中添加的是一个状态判断，
////自动校准2016-7-20
	//				if(Staues[29]==88)//自动校准标志
	
	
// USER START (Optionally insert additional includes)
// USER END
#include <stdlib.h>
#include <string.h>
#include "DIALOG.h"
#include "NANJING.h"
#include "adc.h"
#include "stm32f10x_adc.h"
#include "math.h"//数学计算要加入进去
#include "dac.h"
#include "stm32f10x_exti.h"
#include "stm32f10x_dac.h"
#include "delay.h"
#include "led.h"
//加入了flash 斜率存储
#include "stmflash.h"


//#include "exti.h"
#include "GUI.h"
#include "timer.h"
/*********************************************************************
*
*       Defines
*
**********************************************************************
*/
#define ID_FRAMEWIN_0  	(GUI_ID_USER + 0x00)
#define ID_GRAPH_0  		(GUI_ID_USER + 0x01)
#define ID_BUTTON_0  		(GUI_ID_USER + 0x02)
#define ID_BUTTON_AD  	(GUI_ID_USER + 0x03)
#define ID_BUTTON_2  		(GUI_ID_USER + 0x04)
#define ID_DROPDOWN_0  	(GUI_ID_USER + 0x0A)
#define ID_TEXT_0  			(GUI_ID_USER + 0x1B)
#define ID_TEXT_1  			(GUI_ID_USER + 0x0B)
#define ID_WASHING_0  	(GUI_ID_USER + 0x05)
#define ID_WASHING_stir (GUI_ID_USER + 0x06)
#define ID_TEXT_2  			(GUI_ID_USER + 0x07)
#define ID_TEXT_3  			(GUI_ID_USER + 0x08)
#define ID_TEXT_display (GUI_ID_USER + 0x0E)
#define ID_TEXT_Statue (GUI_ID_USER + 0x1C)//状态文本。by yan
#define ID_TEXT_Statue_on (GUI_ID_USER + 0x1D)//状态文本。by yan
#define Singel_AD  			(GUI_ID_USER + 0x09)
///


#define KEY0  GPIO_ReadInputDataBit(GPIOE,GPIO_Pin_1)//读取按键1
#define KEYx  GPIO_ReadInputDataBit(GPIOE,GPIO_Pin_2)//读取按键2 
#define KEY1  GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_9)//读取按键2 


// USER START (Optionally insert additional defines)
#define MAX_VALUE 180
// USER END

/*********************************************************************
*
*       Static data
*
**********************************************************************
*/



// USER START (Optionally insert additional static data)
/****************
移植xy显示

*****/
WM_HWIN hWin_x;
WM_HWIN hItem_y;
WM_HWIN hItem_Statue_on;

static GRAPH_DATA_Handle  _ahData[5]; // Array of handles for the GRAPH_DATA objects

static GRAPH_SCALE_Handle _hScaleV;   // Handle of vertical scale
static GRAPH_SCALE_Handle _hScaleH;   // Handle of horizontal scale

static unsigned   Staues[30]={0};
static GUI_COLOR _aColor[] = {GUI_RED, GUI_GREEN, GUI_LIGHTBLUE,GUI_GRAY,GUI_LIGHTCYAN}; // Array of colors for the GRAPH_DATA objects

float adc_result;
float adc_result_1;
float adc_result_2;
float caliberate_temp;
float caliberate_resulte[8];
//char display[20],display_point[20];
char *display,*display_point;
float display_float;
static int adc_all_onley=0;
//static int DA_value[4]={0};

extern GUI_CONST_STORAGE GUI_FONT GUI_FontDI24;//引入中文字库
extern GUI_CONST_STORAGE GUI_FONT GUI_Fontsongti47;
extern GUI_CONST_STORAGE GUI_FONT GUI_FontSong36;
extern GUI_CONST_STORAGE GUI_FONT GUI_FontHeti36;
//float sin_x;

//
//要写入到STM32 FLASH的字符串数组
const u8 TEXT_Buffer[]={"FLASH TEST"};


#define SIZE sizeof(TEXT_Buffer)		//数组长度
#define FLASH_SAVE_ADDR  0X0807F000		//设置FLASH 保存地址
#define FLASH_SAVE_ADDR_1  0X0807F010		//设置FLASH 保存地址
u8 datatemp[SIZE];
//

//变量申明

// USER END

/*********************************************************************
*
*       _aDialogCreate 原来
*/
static const GUI_WIDGET_CREATE_INFO _aDialogCreate[] = {
	{ FRAMEWIN_CreateIndirect, "NANJING TECH UNIVERSITY", ID_FRAMEWIN_0, 1, 5, 800, 480, 0, 0x64, 0 },//y
	{ GRAPH_CreateIndirect, "Graph",     ID_GRAPH_0,  18, 182, 355, 233, 0, 0x0, 0 },//y
	{ BUTTON_CreateIndirect, "Stir", ID_WASHING_stir,    410, 190, 120, 80, 0, 0x0, 0 },//stir yy
	
	
	//{ DROPDOWN_CreateIndirect, "Dropdown0", ID_DROPDOWN_0,  681, 240, 93, 37, 0, 0x0, 0 },
	//{ MULTIEDIT_CreateIndirect, "Multiedit", ID_WASHING_Edit, 681, 240, 93, 37, 0, 0x0, 0 },
	{ BUTTON_CreateIndirect, "Calib", ID_BUTTON_0,    600, 191, 120, 80, 0, 0x0, 0 },//检测单次
	{ BUTTON_CreateIndirect, "Start", ID_BUTTON_AD,  500, 50, 150, 80, 0, 0x0, 0 },//开始

	{ BUTTON_CreateIndirect, "Single AD", ID_BUTTON_2, 410, 330, 120, 80, 0, 0x0, 0 },//yan
	{ BUTTON_CreateIndirect, "Washing", ID_WASHING_0, 600, 330, 120, 80, 0, 0x0, 0 },//yan
	
	 { TEXT_CreateIndirect, "Calibrate", ID_TEXT_Statue,  20, 8, 133, 40, 0, 0x64, 0 },//标题y
	 {TEXT_CreateIndirect, "Single", ID_TEXT_3,           20, 50, 130, 40, 0, 0x64, 0 },//标题y
	 { TEXT_CreateIndirect, "Calibrate", ID_TEXT_1,       20, 95, 133, 40, 0, 0x64, 0 },//标题y
	 {TEXT_CreateIndirect, "A / D", ID_TEXT_2,            20, 140, 133, 40, 0, 0x64, 0 },//标题y
	
	 
	{ TEXT_CreateIndirect, "Idling", ID_TEXT_Statue_on,   200, 8, 200, 33, 0, 0x0, 0 },//状态显示by yan
	{ TEXT_CreateIndirect, "Single_Res", Singel_AD,       200, 50, 161, 33, 0, 0x0, 0 },//y
	{ TEXT_CreateIndirect, "Cali_Res", ID_TEXT_0,         200, 95, 172, 33, 0, 0x0, 0 },//y
	{ TEXT_CreateIndirect, "AD_resulte", ID_TEXT_display, 200, 141, 183, 37, 0, 0x0, 0 },//y
	// USER START (Optionally insert additional widgets)


	// USER END

	
};



static void _UserDraw(WM_HWIN hWin, int Stage) {
  if (Stage == GRAPH_DRAW_LAST) {
    char acText[] = "Effective concentration ; EC";
    GUI_RECT Rect;
    GUI_RECT RectInvalid;
    int FontSizeY;

    GUI_SetFont(&GUI_Font16_ASCII);
    FontSizeY = GUI_GetFontSizeY();
    WM_GetInsideRect(&Rect);
    WM_GetInvalidRect(hWin, &RectInvalid);
    Rect.x1 = Rect.x0 + FontSizeY;
    GUI_SetColor(GUI_RED);
    GUI_DispStringInRectEx(acText, &Rect, GUI_TA_HCENTER, strlen(acText), GUI_ROTATE_CCW);
  }
}

// USER END

/*********************************************************************
*
*       _AddValues
*
* Function description
*   This routine calculates new random values in dependence of the previous added values
*   and adds them to the GRAPH_DATA objects
*/

void _sinx(int i)
	{
		u16 sin_x;
		static int ww;
		float sin_out;
		int Add;
		int up_max;
		int Add_2 ;
		sin_out=2*sin(0.05*i);
		sin_x=(int)sin_out*200/3.3+100;
		ww=0;
		DAC_SetChannel1Data(DAC_Align_12b_R,ww);//12位右对齐数据格式设置DAC值
		
		 
		//sin_x=200;
		GRAPH_DATA_YT_AddValue(_ahData[4], ww);//DA输出
		//delay_ms(100);
//		Add_2= (((Get_Adc_Average(ADC_Channel_1,3))*420))/4095;
//		GRAPH_DATA_YT_AddValue(_ahData[2], Add_2);//横坐标在哪里？
//		
//		Add= (((Get_Adc_Average(ADC_Channel_1,3))));//AD采集
//		 GRAPH_DATA_YT_AddValue(_ahData[0], Add);//采集回来
		//i+=1;
		switch(up_max)
		{
			case 10:
				 ww=ww-5;
			 break;
			case 11:
				ww=ww+5;
			break;
		}
				 
		if(ww>300)
			up_max=10;
			
		else if(ww<=300)
			up_max=11;
	}
	
	
	///void functions

static void _AddValues(void) {//进行AD转换///不要多次采集 
			int i;
			static int temp=0;
			int add_temp=Get_Adc_Middle_value(ADC_Channel_1,15);
			int Add_1 = ((add_temp*420))/4095;
			int Add_2 = ((add_temp)*2048)/4095;
			int Add = ((add_temp*1024)/4095);//12位AD，这里是显示不要超出范围实际显示的高度
			 if (Add>=200) 										//超过量程设定
							Add=200;
			 if (Add_2>=200) 										//超过量程设定
							Add_2=200;
			 if (Add_1>=200) 										//超过量程设定
							Add_1=200;
			 
			adc_all_onley=add_temp;
			if(fabs(Add_2-temp)>=10)//跳变的时候显示，门槛值计算方法 =0.02*4096/3.3 如果每次变化是0.02
				for (i=0;i<10;i++){
				Add= ((add_temp)*1024)/4095;
						if (Add>=200)//超过量程设定
						 Add=200;
						GRAPH_DATA_YT_AddValue(_ahData[2], Add_2);//横坐标在哪里？
					 GRAPH_DATA_YT_AddValue(_ahData[0], Add);//横坐标在哪里？
				}
				temp=Add_2;
				GRAPH_DATA_YT_AddValue(_ahData[1], Add_1);//横坐标在哪里？
				GRAPH_DATA_YT_AddValue(_ahData[0], Add);//横坐标在哪里？
				//GRAPH_DATA_YT_AddValue(_ahData[3], Add);//横坐标在哪里？
	}

	/*
	void TIM5_IRQHandler(void)//DA 波形三角波
	{//int w;
		if (TIM_GetITStatus(TIM5, TIM_IT_Update) != RESET)  //检查TIM3更新中断发生与否
			{
			TIM_ClearITPendingBit(TIM5, TIM_IT_Update  );  //清除TIMx更新中断标志 
				switch (DA_value[1])
				{
					case 0:
						DA_value[0]=DA_value[0]+10;
					break;
					case 10:
						DA_value[0]=DA_value[0]-10;
						if (DA_value[0]<=10)
						{
							DA_value[0]=10;
							DA_value[1]=0;
						}
					break;
					
				}
				if (DA_value[0]>=300)
					DA_value[1]=10;
					DAC_SetChannel1Data(DAC_Align_12b_R,DA_value[0]);//12位右对齐数据格式设置DAC值
					GRAPH_DATA_YT_AddValue(_ahData[4], DA_value[0]);//DA输出
			}
	}
	*/
void TIM5_IRQHandler(void)//旧版 DA 波形三角波
	{WM_HWIN hItem_temp;
		if (TIM_GetITStatus(TIM5, TIM_IT_Update) != RESET)  //检查TIM5更新中断发生与否
			{
			TIM_ClearITPendingBit(TIM5, TIM_IT_Update  );  //清除TIMx更新中断标志 
				hItem_y = WM_GetDialogItem(hWin_x, ID_TEXT_1);
				hItem_temp = WM_GetDialogItem(hWin_x, ID_TEXT_0);
				hItem_Statue_on= WM_GetDialogItem(hWin_x,ID_TEXT_Statue_on);//状态显示
				TEXT_SetTextColor(hItem_y, 0x00FF8000);
				TEXT_SetFont(hItem_y, &GUI_FontSong36);
				TEXT_SetFont(hItem_Statue_on, &GUI_FontSong36);
    //TEXT_SetText(hItem, "\xe6\xa0\xa1\xe5\x87\x86\xe5\x80\xbc");//校准值
				//循环计数		
				if (Staues[14]==1)//校准和测量分开
					{
						Staues[17]=0;//
						TEXT_SetTextColor(hItem_Statue_on, 0x000000FF);//显示红色
						TEXT_SetText(hItem_Statue_on," :\xe6\xa0\xa1\xe5\x87\x86\xe4\xb8\xad....");//显示校验中
						
						 switch(Staues[15])//按键两次 校准需要 两次
							 { case 0:
										if(5<=Staues[10]<=20)//开始检测，测量时间变化2016-7-10 等待60，90开始测量by yan
										{
											TEXT_SetText(hItem_y,"\xe7\xad\x89\xe5\xbe\x85..");//第一个时间段开始等待
											if(Staues[10]%2)//选择采用
											{
												
												//caliberate_resulte[0]=ADCvalue_test();
												Staues[13]++;//连续采集次数
												//adc_result_x=ADCvalue_test();
												Staues[1]+=adc_all_onley;//累次采集和
												Staues[2]=Staues[1]/Staues[13];//
												caliberate_resulte[0]=(float)Staues[2]*(3.3/4095);
												display=Float_to_string(caliberate_resulte[0]);
												
												TEXT_SetText(hItem_temp,display);
															
											}
										}
										if(Staues[10]>=21)
										{
												caliberate_resulte[0]=(float)Staues[2]*(3.3/4095);
											  
											 //flash 操作 by yan
											
											  //
											
												Staues[13]=0;
												Staues[1]=0;
												Staues[2]=0;
												Staues[10]=0;
												Staues[15]=0;
												Staues[14]=0;	
											 Staues[27]=0;//清洗标志
												TIM_Cmd(TIM5,DISABLE);		  //停掉中断
												display=Float_to_string(caliberate_resulte[0]);
											
												 STMFLASH_Write(FLASH_SAVE_ADDR_1,(u16*)display,20);//写flash vc0 yan
												//strtof(display,NULL);//by yan
											
												//hItem_temp = WM_GetDialogItem(hWin_x, ID_TEXT_0);
												TEXT_SetText(hItem_temp,display);
											
												TEXT_SetText(hItem_y,"\xe6\xa0\xa1\xe4\xb8\x80");//第一次结果
												    TEXT_SetTextColor(hItem_Statue_on, 0x00FF8000);
														TEXT_SetFont(hItem_Statue_on, GUI_FONT_32B_ASCII);
														TEXT_SetText(hItem_Statue_on, "Please add...");
												//TEXT_SetText(hItem_Statue_on,"please add....");
												Staues[29]=88;//自动校准标志
												TIM5_Int_Init(9999,7199);//1秒产生一个中断
										}
								
								break;
								case 1:
										TEXT_SetFont(hItem_Statue_on, &GUI_FontSong36);
									  TEXT_SetText(hItem_Statue_on," :\xe6\xa0\xa1\xe5\x87\x86\xe4\xb8\xad....");//显示校验中
										if(40<=Staues[10]<=60)//开始检测by yan
										{
											TEXT_SetText(hItem_y,"\xe7\xad\x89\xe5\xbe\x85..");//第一个时间段开始等待
											
											if(Staues[10]%2)//选择采用
											{
												
												//caliberate_resulte[0]=ADCvalue_test();
												Staues[13]++;//连续采集次数
												//adc_result_x=ADCvalue_test();
												Staues[1]+=adc_all_onley;//累次采集和
												Staues[2]=Staues[1]/Staues[13];//
												caliberate_resulte[1]=(float)Staues[2]*(3.3/4095);
												//display=Float_to_string(caliberate_resulte[1]);
												//hItem_temp = WM_GetDialogItem(hWin_x, ID_TEXT_0);
												//TEXT_SetText(hItem_temp,display);
											}
										}
										if(Staues[10]>=61)//by yan
										{
												caliberate_resulte[3]=fabs((caliberate_resulte[1]-caliberate_resulte[0])/caliberate_resulte[7]);
												
												TEXT_SetText(hItem_y,"\xe6\xa0\xa1\xe5\x87\x86\xe5\x80\xbc");//校准值;//第一个时间段开始等待
											
												//STMFLASH_Write(FLASH_SAVE_ADDR,(u16*)TEXT_Buffer,sizeof(caliberate_resulte[3]));//写入校准数据
												display=Float_to_string(caliberate_resulte[3]);
												//test
												//display_float = strtof (display,NULL);// &display_point);转成float by yan
											 // display_point=Float_to_string(display_float);//再转成string by yan
											  
											  STMFLASH_Write(FLASH_SAVE_ADDR,(u16*)display,20);//写flash by yan
											  Staues[24]=10;//存储斜率？
											
										
											
												TEXT_SetText(hItem_Statue_on,"\xe6\xa0\xa1\xe9\xaa\x8c\xe7\xbb\x93\xe6\x9d\x9f");//显示校验结束"\xe6\xa0\xa1\xe9\xaa\x8c\xe4\xb8\xad"
												
												Staues[13]=0;
												Staues[1]=0;
												Staues[2]=0;
												Staues[10]=0;
												Staues[14]=0;
												//Staues[15]=0;
												Staues[27]=18;//搅拌开始?
												
										}
										
										
								break;
							}
						}
					//自动校准2016-7-20
					if(Staues[29]==88)//自动校准标志判断是否有 标准样注入by yan
					{
						//if(Staues[10]<=100)
						//if(Staues[27]==0)
						//{
								TEXT_SetText(hItem_y,"\xe6\xa0\xa1\xe4\xb8\x80");//第一次结果
												    TEXT_SetTextColor(hItem_Statue_on, 0x00FF8000);
														TEXT_SetFont(hItem_Statue_on, GUI_FONT_32B_ASCII);
														TEXT_SetText(hItem_Statue_on, "Please add...");
					//	}
												//TEXT_SetText(hItem_Statue_on,"please add....");
						//if(Staues[10]%2)//选择采样
											{
									if(Staues[28]==0)
														{//第一次
															TEXT_SetText(hItem_Statue_on, "this first");
															{
															Staues[13]++;//连续采集次数
															//adc_result_x=ADCvalue_test();
															Staues[1]+=adc_all_onley;//累次采集和
															Staues[2]=Staues[1]/Staues[13];//
																Staues[3]=Staues[2];
															if(Staues[13]==5)//计算10次停一段时间
															{Staues[10]=0;
																Staues[13]=0;
																Staues[1]=0;
																Staues[2]=0;	
																Staues[28]=10;//停掉
															}
														}
													}
									if((Staues[28]==10)&&Staues[10]>=5)//第二次	五秒后
												{
														TEXT_SetText(hItem_Statue_on, "this second");
													Staues[13]++;//连续采集次数
													//adc_result_x=ADCvalue_test();
													Staues[1]+=adc_all_onley;//累次采集和
													Staues[2]=Staues[1]/Staues[13];//
													Staues[4]=Staues[2];
													if(Staues[13]==5)//计算10次停一段时间
													{Staues[10]=0;
														Staues[13]=0;
														Staues[1]=0;
														Staues[2]=0;	
														Staues[28]=14;//第二次采集结束并判断
												}
													
											}
									if (Staues[28]==14)//前后比较是否有阶跃相应。置标志
										 {
												 TEXT_SetText(hItem_Statue_on, "the compare");
											 if(abs(Staues[4]-Staues[3])>=20)//判断阶梯
											 {
												 
												 TEXT_SetFont(hItem_Statue_on, &GUI_FontSong36);
												 TEXT_SetTextColor(hItem_Statue_on, 0x000000FF);//显示红色
												TEXT_SetText(hItem_Statue_on," :\xe6\xa0\xa1\xe5\x87\x86\xe4\xb8\xad....");//显示校验中
												 
													GPIO_SetBits(GPIOB,GPIO_Pin_8);///按键提示音GPIO_ResetBits(GPIOB,GPIO_Pin_8);///按键提示音
													 delay_ms(1000);
													GPIO_ResetBits(GPIOB,GPIO_Pin_8);///按键提示音
												 Staues[29]=0;//跳出检测检测
												 Staues[28]=0;
													Staues[27]=10;
												 Staues[10]=0;
												 Staues[14]=1;//自动回到第二次校准
												 Staues[4]=Staues[3]=Staues[2]=Staues[1]=0;
													//by yan自动清洗
												 /*
													TIM_Cmd(TIM3,DISABLE);	//停掉搅拌
													TIM4_PWM_Init(2899,1000);	//新版清洗用GPIO pb6 口 pwm控制
													TIM_SetCompare1(TIM4,100);
													for(Staues[10]=0;Staues[10]<=20;Staues[10]++)//借用一下Staues[10]
													{
													 delay_ms(1000);//清洗20*2秒
													 delay_ms(1000);//
														delay_ms(1000);//清洗20*2秒
													 delay_ms(1000);//
													}
													Staues[10]=0;//重新归零
													TIM_SetCompare1(TIM4,2988);//清洗结束
													TIM3_Int_Init(30,400);//搅拌开启
													*/
													//自动清洗结束
													 Staues[14]=1;//自动回到第二次校准
													Staues[15]=1;//第二次校准值循环
												 TIM5_Int_Init(9999,7199);//1秒产生一个中断
											 }
											else
											{
												Staues[28]=0;
												 Staues[4]=Staues[3]=Staues[2]=Staues[1]=0;
											}
										 }
						
							}
						}//自动校准结束
						
					if((Staues[17]==10)&&(Staues[14]==0))//采集测量单次
					{
						hItem_y = WM_GetDialogItem(hWin_x, ID_TEXT_3);
						hItem_temp = WM_GetDialogItem(hWin_x, Singel_AD);
						TEXT_SetFont(hItem_y, &GUI_FontSong36);
						//
						if(caliberate_resulte[3]<=0.00001)//斜率值有判断
						{
							TEXT_SetTextColor(hItem_y, 0x000000FF);//显示红色
							TEXT_SetText(hItem_y,"\xe8\xaf\xb7\xe6\xa0\xa1\xe5\x87\x86");//请校准
						}
						else
						{
								TEXT_SetText(hItem_Statue_on,":\xe9\x87\x87\xe9\x9b\x86\xe4\xb8\xad....");//采集中显示
						if(40<=Staues[10]<=60)//开始检测by yan
								{
									TEXT_SetText(hItem_y,"\xe7\xad\x89\xe5\xbe\x85");//等待
									if(Staues[10]%2)//选择采用
									{
										//caliberate_resulte[0]=ADCvalue_test();
										Staues[13]++;//连续采集次数
										//adc_result_x=ADCvalue_test();
										Staues[1]+=adc_all_onley;//累次采集和
										Staues[2]=Staues[1]/Staues[13];//
										caliberate_resulte[1]=(float)Staues[2]*(3.3/4095);
										//归一化处理2016-4-13
										
										
										//
										display=Float_to_string(caliberate_resulte[1]);

										TEXT_SetText(hItem_temp,"Waiting...");			
									}
								}
						if(Staues[10]>=61)//by yan
								{
									TEXT_SetText(hItem_Statue_on,":\xe9\x87\x87\xe9\x9b\x86\xe7\xbb\x93\xe6\x9d\x9f");//采集结束显示
									TEXT_SetText(hItem_y,"\xe6\xb5\x93\xe5\xba\xa6");//浓度
									caliberate_resulte[5]=(float)Staues[2]*(3.3/4095);
									if (Staues[24]==0)
									{
										STMFLASH_Read(FLASH_SAVE_ADDR,(u16*)datatemp,10);//读flash by yan斜率值
            
											display_float= strtof ((char*)datatemp,NULL);//转换成浮点数小数 yan
											caliberate_resulte[3]=display_float;
									//if(caliberate_resulte[3]<=0.01)
										//{
										//	TEXT_SetText(hItem_y,"\xe8\xaf\xb7\xe6\xa0\xa1\xe5\x87\x86");//请校准
										//}
									//	else
										//{
											//caliberate_resulte[6]=Concentration_return(caliberate_resulte[3],caliberate_resulte[0],caliberate_resulte[5]);
										//}
									}
									
									//else  有时候显示不出来测试的结果2016-
									//{
									caliberate_resulte[6]=Concentration_return(caliberate_resulte[3],caliberate_resulte[0],caliberate_resulte[5]);
									hItem_y = WM_GetDialogItem(hWin_x, Singel_AD);
									
									display=Float_to_string(caliberate_resulte[6]);
									TEXT_SetText(hItem_y,display);//就是浓度啊2016-5-6
									delay_ms(1000);
									//	}
									
									Staues[17]=12;//单次采样
									Staues[10]=0;//循环次数
									Staues[13]=0;//累加次数
									Staues[1]=0;
									Staues[2]=0;//累加清零
									//自动清洗
									Staues[27]=18;//单次采集结束标志。
									
								}
						
						//}
				
					}
				
				}
					if(Staues[27]==18)
					{
						 {
							 Staues[27]=0;//清除清洗标志
									GPIO_SetBits(GPIOB,GPIO_Pin_8);///按键提示音GPIO_ResetBits(GPIOB,GPIO_Pin_8);///按键提示音
									 delay_ms(1000);
									GPIO_ResetBits(GPIOB,GPIO_Pin_8);///按键提示音
									
									//by yan
									TIM_Cmd(TIM3,DISABLE);	//停掉搅拌
									TIM4_PWM_Init(2899,1000);	//新版清洗用GPIO pb6 口 pwm控制
									TIM_SetCompare1(TIM4,100);
									for(Staues[10]=0;Staues[10]<=20;Staues[10]++)//借用一下Staues[10]
									{
									 delay_ms(1000);//清洗20*2秒
									 delay_ms(1000);//
										delay_ms(1000);//清洗20*2秒
									 delay_ms(1000);//
									}
									Staues[10]=0;//重新归零
									//应该直接pwm控制停止，测试一下
									TIM_SetCompare1(TIM4,2988);//清洗结束
									//直接停止PWM控制
									TIM3_Int_Init(30,400);//搅拌开启
									//自动清洗结束
										
									//停止
													
									//
									TIM_Cmd(TIM5,DISABLE);		  //停掉中断
								  }
					}
					Staues[10]++;
			}
	}

//旧版做的是定时控制
	/*
void TIM4_IRQHandler(void)//定时器中断实现标准样检测，20秒后开始检测
	{WM_HWIN hItem_temp;
		
		if (TIM_GetITStatus(TIM4, TIM_IT_Update) != RESET)  //检查TIM3更新中断发生与否
			{
			TIM_ClearITPendingBit(TIM4, TIM_IT_Update  );  //清除TIMx更新中断标志 
			hItem_y = WM_GetDialogItem(hWin_x, ID_TEXT_1);
				//循环计数		
				if (Staues[14]==1)//校准和测量分开
					{
						Staues[17]=0;
						 switch(Staues[15])//按键两次 校准需要 两次
							 { case 0:
										if(20<=Staues[10]<=50)//开始检测
										{
											TEXT_SetText(hItem_y,"Once wait..");//第一个时间段开始等待
											if(Staues[10]%2)//选择采用
											{
												
												//caliberate_resulte[0]=ADCvalue_test();
												Staues[13]++;//连续采集次数
												//adc_result_x=ADCvalue_test();
												Staues[1]+=adc_all_onley;//累次采集和
												Staues[2]=Staues[1]/Staues[13];//
												caliberate_resulte[0]=(float)Staues[2]*(3.3/4095);
												display=Float_to_string(caliberate_resulte[0]);
												hItem_temp = WM_GetDialogItem(hWin_x, ID_TEXT_0);
												TEXT_SetText(hItem_temp,display);
															
											}
										}
										if(Staues[10]>=51)
										{
												caliberate_resulte[0]=(float)Staues[2]*(3.3/4095);
												Staues[13]=0;
												Staues[1]=0;
												Staues[2]=0;
												Staues[10]=0;
												Staues[15]++;
												//Staues[14]=0;	
												TIM_Cmd(TIM4,DISABLE);		  //停掉中断
												display=Float_to_string(caliberate_resulte[0]);
												hItem_temp = WM_GetDialogItem(hWin_x, ID_TEXT_0);
												TEXT_SetText(hItem_temp,display);
												
												TEXT_SetText(hItem_y,"Once ok");//第一个时间段开始等待
										}
								
								break;
								case 1:
										if(20<=Staues[10]<=50)//开始检测
										{
											TEXT_SetText(hItem_y,"Sec wait..");//第一个时间段开始等待
											if(Staues[10]%2)//选择采用
											{
												
												//caliberate_resulte[0]=ADCvalue_test();
												Staues[13]++;//连续采集次数
												//adc_result_x=ADCvalue_test();
												Staues[1]+=adc_all_onley;//累次采集和
												Staues[2]=Staues[1]/Staues[13];//
												caliberate_resulte[1]=(float)Staues[2]*(3.3/4095);
												display=Float_to_string(caliberate_resulte[1]);
												hItem_temp = WM_GetDialogItem(hWin_x, ID_TEXT_0);
												TEXT_SetText(hItem_temp,display);
											}
										}
										if(Staues[10]>=51)
										{
												caliberate_resulte[3]=fabs((caliberate_resulte[1]-caliberate_resulte[0])/caliberate_resulte[7]);
											
												TEXT_SetText(hItem_y,"Cali ok");//第一个时间段开始等待
												display=Float_to_string(caliberate_resulte[3]);
												//校准写入SD卡
											//  write_to_txt(ffp,"0:/text","songjeduia",12);
												hItem_temp = WM_GetDialogItem(hWin_x, ID_TEXT_0);
												TEXT_SetText(hItem_temp,display);
												
												Staues[13]=0;
												Staues[1]=0;
												Staues[2]=0;
												Staues[10]=0;
												Staues[14]=0;
												Staues[15]=0;
											
												TIM_Cmd(TIM4,DISABLE);		  //停掉中断
										}
										
										
								break;
							}
						}
					if((Staues[17]==10)&&(Staues[14]==0))//显示单次
					{
						hItem_y = WM_GetDialogItem(hWin_x, ID_TEXT_3);
						
						if(20<=Staues[10]<=50)//开始检测
								{
									TEXT_SetText(hItem_y,"Sing wait..");
									if(Staues[10]%2)//选择采用
									{
										//caliberate_resulte[0]=ADCvalue_test();
										Staues[13]++;//连续采集次数
										//adc_result_x=ADCvalue_test();
										Staues[1]+=adc_all_onley;//累次采集和
										Staues[2]=Staues[1]/Staues[13];//
										caliberate_resulte[1]=(float)Staues[2]*(3.3/4095);
										display=Float_to_string(caliberate_resulte[1]);
										hItem_temp = WM_GetDialogItem(hWin_x, Singel_AD);
										TEXT_SetText(hItem_temp,display);			
									}
								}
						if(Staues[10]>=51)
								{
									TEXT_SetText(hItem_y,"Single ok");
									caliberate_resulte[5]=(float)Staues[2]*(3.3/4095);
									caliberate_resulte[6]=Concentration_return(caliberate_resulte[3],caliberate_resulte[0],caliberate_resulte[5]);
									hItem_y = WM_GetDialogItem(hWin_x, Singel_AD);
									display=Float_to_string(caliberate_resulte[6]);
									TEXT_SetText(hItem_y,display);
									Staues[17]=12;//单次采样
									Staues[10]=0;//循环次数
									Staues[13]=0;//累加次数
									Staues[1]=0;
									Staues[2]=0;//累加清零
									
									TIM_Cmd(TIM4,DISABLE);		  //停掉中断
								}
						
						}
				Staues[10]++;
		
			}
	}
	*/
static void _IntToStr(char * pBuffer, int Num) {
	char * p;
	char   c;

	if (Num < 0) {
		*pBuffer++ = '-';
		Num = -Num;
	}
	p = pBuffer;
	if (Num) {
		while (Num) {
			*pBuffer++ = '0' + (Num % 10);
			Num /= 10;
		}
	} else {
		*pBuffer++ = '0';
	}
	*pBuffer-- = 0;
	while (p < pBuffer) {
		c          = *p;
		*p++       = *pBuffer;
		*pBuffer-- = c;
	}
}

/*********************************************************************
*
*       _cbDialog
*/
static void _cbDialog(WM_MESSAGE * pMsg) {
WM_HWIN hItem;
  int     NCode;
  int     Id;
	int     xdir;
	char temp_string[20];
	//const char* displaychinese="\xe5\x8d\x97\xe4\xba\xac\xe5\xb7\xa5\xe4\xb8\x9a\xe5\xa4\xa7\xe5\xad\xa6\xe5\x9b\xbd\xe5\xae\xb6";
  const char* displaychinese="\xe5\x8d\x97\xe4\xba\xac\xe5\xb7\xa5\xe4\xb8\x9a\xe5\xa4\xa7\xe5\xad\xa6";
	// USER START (Optionally insert additional variables)
//	WM_HWIN  hDlg;
	

	Adc_Init();		  		//ADC初始化
	//Dac1_Init();
	
	 
  //WM_HWIN  hItem;

  //hDlg = pMsg->hWin;//加了这一句为啥就可以了：
  // USER END

  switch (pMsg->MsgId) {
  case WM_INIT_DIALOG:
		
    //
    // Initialization of 'NANJING TECH UNIVERSITY'
		 GUI_UC_SetEncodeUTF8();
	//GUI_SetOrientation(GUI_MIRROR_Y);//旋转屏幕
	
    //
    hItem = pMsg->hWin;
	
		TEXT_SetFont(hItem,&GUI_FontHeti36);
		//TEXT_SetText(hItem,"English");
		//TEXT_SetText(hItem,"\xe5\x8d\x97\xe4\xba\xac\xe5\xa4\xa7\xe5\xad\xa6");
    FRAMEWIN_SetTitleHeight(hItem, 40);
    FRAMEWIN_SetFont(hItem, &GUI_FontHeti36);
		FRAMEWIN_SetText(hItem,displaychinese);//\xe9\x87\x8d\xe7\x82\xb9\xe5\xae\x9e\xe9\xaa\x8c\xe5\xae\xa4 \xe5\x8d\x97\xe4\xba\xac\xe5\xb7\xa5\xe7\xa8\x8b\xe5\xad\xa6\xe9\x99\xa2\xe5\xb7\xa5\xe4\xb8\x9a\xe4\xb8\xad\xe5\xbf\x83\xe8\x81\x94\xe5\x90\x88\xe7\xa0\x94\xe5\x88\xb6");
    FRAMEWIN_SetTextAlign(hItem, GUI_TA_HCENTER | GUI_TA_VCENTER);
    FRAMEWIN_SetTextColor(hItem, 0x00C08000);
    //
    // Initialization of 'Graph'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_GRAPH_0);
    GRAPH_SetBorder(hItem, 2, 2, 2, 8);
	
	//不需要三个波形
	
    //for (i = 0; i < GUI_COUNTOF(_aColor); i++) {
      //_aValue[0] = Get_Adc_Average(ADC_Channel_1,3)% 250;
	
      _ahData[0] = GRAPH_DATA_YT_Create(_aColor[0], 500, 0, 0);
      GRAPH_AttachData(hItem, _ahData[0]);
			_ahData[1] = GRAPH_DATA_YT_Create(_aColor[1], 500, 0, 0);//对比一下
      GRAPH_AttachData(hItem, _ahData[1]);
			_ahData[2] = GRAPH_DATA_YT_Create(_aColor[2], 500, 0, 0);//对比一下
      GRAPH_AttachData(hItem, _ahData[2]);
			_ahData[3] = GRAPH_DATA_YT_Create(_aColor[3], 500, 0, 0);//对比一下
      GRAPH_AttachData(hItem, _ahData[3]);
			_ahData[4] = GRAPH_DATA_YT_Create(_aColor[4], 500, 0, 0);//对比一下
      GRAPH_AttachData(hItem, _ahData[4]);
			
		
	
		
		
    //
    // Set graph attributes
    //
    GRAPH_SetGridDistY(hItem, 25);
    GRAPH_SetGridVis(hItem, 1);
    GRAPH_SetGridFixedX(hItem, 1);
   GRAPH_SetUserDraw(hItem, _UserDraw);
//		GRAPH_SetVSizeX(hItem,1000);//添加滑块
    //
    // Create and add vertical scale
    //
    _hScaleV = GRAPH_SCALE_Create( 35, GUI_TA_RIGHT, GRAPH_SCALE_CF_VERTICAL, 25);
    GRAPH_SCALE_SetTextColor(_hScaleV, GUI_YELLOW);
    GRAPH_AttachScale(hItem, _hScaleV);
    //
    // Create and add horizontal scale
    //
    _hScaleH = GRAPH_SCALE_Create(100, GUI_TA_HCENTER, GRAPH_SCALE_CF_HORIZONTAL, 50);//坐标值在此地
    GRAPH_SCALE_SetTextColor(_hScaleH, GUI_DARKGREEN);
    GRAPH_AttachScale(hItem, _hScaleH);
//	
			
    //
    // Initialization of 'AD'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_0);//y
    BUTTON_SetFont(hItem,  &GUI_Fontsongti47);
    BUTTON_SetText(hItem, "\xe6\xa0\xa1\xe5\x87\x86");//y
		//BUTTON_SetDefaultTextColor(GUI_RED,BUTTON_CI_PRESSED);
    //
	 
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_AD);//y开始
		BUTTON_SetFont(hItem, &GUI_Fontsongti47);
		BUTTON_SetText(hItem, "\xe5\xbc\x80\xe5\xa7\x8b");//y
   
    //BUTTON_SetFont(hItem, GUI_FONT_16B_ASCII);
    //BUTTON_SetText(hItem, "Start");ID_WASHING_stir
    //
		hItem = WM_GetDialogItem(pMsg->hWin, ID_WASHING_stir);//y
		BUTTON_SetFont(hItem, &GUI_Fontsongti47);
    BUTTON_SetText(hItem, "\xe6\x90\x85\xe6\x8b\x8c");
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_2);//y
    BUTTON_SetFont(hItem, &GUI_Fontsongti47);
    BUTTON_SetText(hItem, "\xe9\x87\x87\xe9\x9b\x86");//y采集
		 //BUTTON_Set
    //
		hItem = WM_GetDialogItem(pMsg->hWin, ID_WASHING_0);//y
		BUTTON_SetFont(hItem, &GUI_Fontsongti47);
    BUTTON_SetText(hItem, "\xe6\xb8\x85\xe6\xb4\x97");//清洗
    // Initialization of 'Text'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_TEXT_0);//校准结果显示 Caliberate[3]
    TEXT_SetTextColor(hItem, 0x00FF8000);
    TEXT_SetFont(hItem, GUI_FONT_32B_ASCII);
    TEXT_SetText(hItem, "0.000");
   //TEXT_SetTextAlign(hItem, GUI_TA_HCENTER | GUI_TA_VCENTER);
    // USER START (Optionally insert additional code for further widget initialization)
		
		hItem = WM_GetDialogItem(pMsg->hWin, ID_TEXT_Statue_on);//状态值显示
    TEXT_SetTextColor(hItem, 0x00FF8000);
    TEXT_SetFont(hItem, GUI_FONT_32B_ASCII);
    TEXT_SetText(hItem, "Idle");//空闲
   //TEXT_SetTextAlign(hItem, GUI_TA_HCENTER | GUI_TA_VCENTER);
    // USER START (Optionally insert additional code for further widget initialization)
		
		hItem = WM_GetDialogItem(pMsg->hWin, ID_TEXT_1);
    TEXT_SetTextColor(hItem, 0x00FF8000);
    TEXT_SetFont(hItem, &GUI_FontSong36);
    TEXT_SetText(hItem, "\xe6\xa0\xa1\xe5\x87\x86\xe5\x80\xbc");//校准值
		
	
		
    //TEXT_SetTextAlign(hItem, GUI_TA_HCENTER | GUI_TA_VCENTER);
		hItem = WM_GetDialogItem(pMsg->hWin, ID_TEXT_2);
    TEXT_SetTextColor(hItem, 0x00FF8000);
    TEXT_SetFont(hItem,  &GUI_FontSong36);
    TEXT_SetText(hItem, "\xe9\x87\x87\xe6\xa0\xb7\xe5\x80\xbc");//采样值
		
		hItem = WM_GetDialogItem(pMsg->hWin, ID_TEXT_display);
    TEXT_SetTextColor(hItem, 0x00FF8000);
    TEXT_SetFont(hItem, GUI_FONT_32B_ASCII);
    TEXT_SetText(hItem, "0.000");

			hItem = WM_GetDialogItem(pMsg->hWin, ID_TEXT_3);
    TEXT_SetTextColor(hItem, 0x00FF8000);
    TEXT_SetFont(hItem, &GUI_FontSong36);
    TEXT_SetText(hItem, "\xe6\xb5\x93\xe5\xba\xa6");//y浓度
		
		
		//状态
		hItem = WM_GetDialogItem(pMsg->hWin, ID_TEXT_Statue);
    TEXT_SetTextColor(hItem, 0x00FF8000);
    TEXT_SetFont(hItem, &GUI_FontSong36);
    TEXT_SetText(hItem, "\xe7\x8a\xb6\xe6\x80\x81\\:");//y状态
			///Down_list
	 	hItem = WM_GetDialogItem(pMsg->hWin, Singel_AD);
    TEXT_SetTextColor(hItem, 0x00FF8000);
    TEXT_SetFont(hItem, GUI_FONT_32B_ASCII);
    TEXT_SetText(hItem, "0.000");
    // USER END
    break;
  case WM_NOTIFY_PARENT:
    Id    = WM_GetId(pMsg->hWinSrc);
    NCode = pMsg->Data.v;
    switch(Id) {
    case ID_BUTTON_0: // Notifications sent by 'caliberate'//检测按键
      switch(NCode) 
				{
      case WM_NOTIFICATION_CLICKED:
				Staues[0]=1;//开始采集显示波形
        // USER START (Optionally insert code for reacting on notification message)
			  // USER START (Optionally insert code for reacting on notification message)
        hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_0);
			//BUTTON_SetText(hItem, "BEEP");
			//BUTTON_SetFont(hItem, GUI_FONT_24_ASCII);
			//LED_Init();
				caliberate_resulte[7]=1.000;//标准样品的浓度这里 是单位值 即是一个单位
			  Staues[14]=1;
//						//GUI_Clear();caliberate_temp
//			   switch(Staues[15])
//					 {
//					 case 1:
//						TIM4_Int_Init(9999,7199);//1秒产生一个中断
//					 break;
//					 case 2:
//						TIM4_Int_Init(9999,7199);//1秒产生一个中断
//					 break;
//						}
//					  Staues[15]++;
//						if (Staues[15]>=3)
//							Staues[15]=0;
			
			 //}
					TIM5_Int_Init(9999,7199);//1秒产生一个中断
					GPIO_SetBits(GPIOB,GPIO_Pin_8);///按键提示音GPIO_ResetBits(GPIOB,GPIO_Pin_8);///按键提示音
					 delay_ms(1000);
					GPIO_ResetBits(GPIOB,GPIO_Pin_8);///按键提示音
        break;
      case WM_NOTIFICATION_RELEASED:
         

				
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_AD: // Notifications sent by 'Start，开始按键
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
				//xdir=GUI_SetOrientation(GUI_TA_VCENTER);
				//_IntToStr(temp_string,xdir);
				Staues[0]=1;//开始采集显示波形
								hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_AD);
					 //BUTTON_SetText(hItem,temp_string);
					BUTTON_SetFont(hItem, &GUI_Fontsongti47);
				if(Staues[16]==1)
				{
					Staues[16]=0;

					BUTTON_SetText(hItem, "\xe5\xbc\x80\xe5\xa7\x8b");//y
					// 测试
					
					//BUTTON_SetText(hItem,"start");
//					//测试flash
//					STMFLASH_Write(FLASH_SAVE_ADDR,(u16*)TEXT_Buffer,SIZE);
//						hItem = WM_GetDialogItem(hWin_x, Singel_AD);//by yan
//					STMFLASH_Read(FLASH_SAVE_ADDR,(u16*)datatemp,SIZE);
//											//	display_point=Float_to_string(display_float);//再转成string by yan
//												TEXT_SetText(hItem,(char*)datatemp);//by yan
				}
				else if (Staues[16]==0)
				{
					Staues[16]=1;
						//hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_AD);
				BUTTON_SetText(hItem, "\xe5\xbc\x80\xe5\xa7\x8b");//y开始
				}
				
				GPIO_SetBits(GPIOB,GPIO_Pin_8);///按键提示音GPIO_ResetBits(GPIOB,GPIO_Pin_8);///按键提示音
				 delay_ms(1000);
				GPIO_ResetBits(GPIOB,GPIO_Pin_8);///按键提示音
        break;
      case WM_NOTIFICATION_RELEASED:
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
			
      break;
    case ID_BUTTON_2: //固定时间测量按钮
			
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
				Staues[0]=1;//开始采集显示波形
				//	Statues
				//if((Staues[14]==0)&&(caliberate_resulte[3]>0))//校准结束
			if(Staues[14]==0)//校准结束
				{
					if(Staues[24]==0)//调用存储的校验值，并显示红色
					{
							//  write_to_txt(ffp,"0:/text","songjeduia",12);
							hItem = WM_GetDialogItem(pMsg->hWin, ID_TEXT_0);//by yan
					
						 
						STMFLASH_Read(FLASH_SAVE_ADDR,(u16*)datatemp,10);//读flash by yan斜率值
            
						display_float= strtof ((char*)datatemp,NULL);//转换成浮点数小数 yan
						caliberate_resulte[3]=display_float;
						display_point=Float_to_string(caliberate_resulte[3]);//再转成 string by yan
						
							TEXT_SetTextColor(hItem, 0x000000FF);//显示红色

						
						TEXT_SetText(hItem,display_point);//by yan
						
						STMFLASH_Read(FLASH_SAVE_ADDR_1,(u16*)datatemp,10);//读flash by yan 初始值vc0
						display_float = strtof ((char*)datatemp,NULL);
						caliberate_resulte[0]=display_float;//数组有些问题？数组和指针的关系by yan
						//display_point=Float_to_string(caliberate_resulte[0]);
						//TEXT_SetText(hItem,display_point);//by yan
					}
					else 
					{ 
						hItem = WM_GetDialogItem(pMsg->hWin, ID_TEXT_0);//by yan
						display_point=Float_to_string(caliberate_resulte[3]);//再转成 string by yan
							TEXT_SetTextColor(hItem, 0x00000000);//显示黑色
						TEXT_SetText(hItem,display_point);//by yan
					}
						TIM5_Int_Init(9999,7199);//1秒产生一个中断
						Staues[17]=10;//
		//				hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_2);
		//			   
		//				BUTTON_SetText(hItem,"Waitting");
				}
        // USER START (Optionally insert code for reacting on notification message)
				GPIO_SetBits(GPIOB,GPIO_Pin_8);///按键提示音GPIO_ResetBits(GPIOB,GPIO_Pin_8);///按键提示音
				 delay_ms(1000);
				GPIO_ResetBits(GPIOB,GPIO_Pin_8);///按键提示音
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
			
						// USER START (Optionally insert code for reacting on notification message)
						// USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    // USER START (Optionally insert additional code for further Ids)
			//stir
			
			
		case ID_WASHING_stir: // 搅拌
			
		//	hItem_temp= WM_GetDialogItem(pMsg->hWin, ID_DROPDOWN_0);
		//  temp_int=DROPDOWN_GetSel(hItem);
		
			
				switch(NCode) {
				case WM_NOTIFICATION_CLICKED:
					if(Staues[19]==0)
					{
						
						//SN_Number=SN_Number&(~4);
						
						//GPIO_ResetBits(GPIOB,GPIO_Pin_7); //旧版enable stir pb9 频率/pb7使能/pb6方向控制步进电机
						//GPIO_ResetBits(GPIOB,GPIO_Pin_6);
							GPIO_ResetBits(GPIOG,GPIO_Pin_14); //新版ena
						
						GPIO_ResetBits(GPIOB,GPIO_Pin_3); //新版enable stir pb4 频率/pb3使能/pb9方向控制步进电机
						GPIO_SetBits(GPIOB,GPIO_Pin_9);
							//GPIO_SetBits(GPIOB,GPIO_Pin_3); //在led.c 中初始化 off enanble
						//	GPIO_SetBits(GPIOB,GPIO_Pin_9);
						//GPIO_SetBits(GPIOB,GPIO_Pin_5);
						
						//_IntToStr(temp_string,Staues[18]);
						
//						
//						hItem = WM_GetDialogItem(hWin_x, Singel_AD);
//						STMFLASH_Read(FLASH_SAVE_ADDR,(u16*)datatemp,20);//读出flash 中的内容 yan
//						display_float = strtof ((char*)datatemp,NULL);//转换成浮点数小数       yan
//						
//						display_point=Float_to_string(display_float+19.090);//再转成 string by yan
//						TEXT_SetText(hItem,(char*)display_point);//在显示
						//TEXT_SetText(hItem,(char*)datatemp);//
						
						TIM3_Int_Init(30,400);//旧版本步进电机step控制频
						//TIM3_Int_Init(20,400);//旧版本步进电机step控制频率
						Staues[19]=1;
						
					}
						else
						{
							GPIO_SetBits(GPIOB,GPIO_Pin_3); //在led.c 中初始化 off enanble
							GPIO_SetBits(GPIOG,GPIO_Pin_14); //
							GPIO_SetBits(GPIOB,GPIO_Pin_9);
							TIM_Cmd(TIM3,DISABLE);	
							Staues[19]=0;
							
							//hItem = WM_GetDialogItem(hWin_x, Singel_AD);
						//STMFLASH_Read(FLASH_SAVE_ADDR,(u16*)datatemp,20);
											//	display_point=Float_to_string(display_float);//再转成string by yan
						//TEXT_SetText(hItem,"");//
							
						}
						
				GPIO_SetBits(GPIOB,GPIO_Pin_8);///按键提示音GPIO_ResetBits(GPIOB,GPIO_Pin_8);///按键提示音
				 delay_ms(1000);
				GPIO_ResetBits(GPIOB,GPIO_Pin_8);///按键提示音
							//GPIO_ResetBits(GPIOB,GPIO_Pin_8);///按键提示音
						//GUI_Delay(500);
				
					// USER END
					break;
				case WM_NOTIFICATION_RELEASED:
					
				
					// USER START (Optionally insert code for reacting on notification message)
				  	//PBout(8)=0;
					// USER END
					break;
				// USER START (Optionally insert additional code for further notification handling)
				// USER END
				}
				break;
			
			//Washing
			
		case ID_WASHING_0: // Notifications sent by 'Cliberate_2'
				switch(NCode) {
					
				case WM_NOTIFICATION_CLICKED:
					//TIM5_Int_Init(4999,7199);//三角波
					if(Staues[18]==1)
						Staues[18]=0;
					else
						Staues[18]=1;
						
					GPIO_SetBits(GPIOB,GPIO_Pin_8);///按键提示音GPIO_ResetBits(GPIOB,GPIO_Pin_8);///按键提示音
					 delay_ms(1000);
					GPIO_ResetBits(GPIOB,GPIO_Pin_8);///按键提示音
					break;
				case WM_NOTIFICATION_RELEASED:
					// USER START (Optionally insert code for reacting on notification message)
				
					// USER END
					break;
				// USER START (Optionally insert additional code for further notification handling)
				// USER END
				}
				break;
				
				//end washing
				
			// USER END
			}
			break;
	
	//stir
		
		
		//
		
		
  // USER START (Optionally insert additional message handling)
  // USER END
  default:
    WM_DefaultProc(pMsg);
    break;
  }
}

/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
/*********************************************************************
*
*       CreateNANJING TECH UNIVERSITY
*/

WM_HWIN CreateNANJING(void) {
  WM_HWIN hWin;
	 //WM_HWIN hDlg;
		WM_HWIN hItem;
	char *display1;
	static int led0pwmval=2899;
	float temp_compare;
	static int Da_i;
	static int ww;
	int   Cliberate[15]={0};
	//float temp_compare1;
	float adc_result_x;
//	int up_max=0;
//	int Statues_rc[5]={0};
	LED_Init();//GPIO口使能
	LED_Init_2();//GPIO 口使能
	Dac1_Init();//da 初始化
	Da_i=20;
	ww=20;
	
	//校验值清0
	caliberate_resulte[0]=0,caliberate_resulte[3]=0;
	Staues[24]=0; 
	//
	//更换皮肤后 很多设置无效了
//	BUTTON_SetDefaultSkin(BUTTON_SKIN_FLEX); 
//	CHECKBOX_SetDefaultSkin(CHECKBOX_SKIN_FLEX);
//	DROPDOWN_SetDefaultSkin(DROPDOWN_SKIN_FLEX);
//	FRAMEWIN_SetDefaultSkin(FRAMEWIN_SKIN_FLEX);
//	HEADER_SetDefaultSkin(HEADER_SKIN_FLEX);
//	MENU_SetDefaultSkin(MENU_SKIN_FLEX);
//	MULTIPAGE_SetDefaultSkin(MULTIPAGE_SKIN_FLEX);
//	PROGBAR_SetDefaultSkin(PROGBAR_SKIN_FLEX);
//	RADIO_SetDefaultSkin(RADIO_SKIN_FLEX);
//	SCROLLBAR_SetDefaultSkin(SCROLLBAR_SKIN_FLEX);
//	SLIDER_SetDefaultSkin(SLIDER_SKIN_FLEX);
//	SPINBOX_SetDefaultSkin(SPINBOX_SKIN_FLEX);
	///更换皮肤
  hWin = GUI_CreateDialogBox(_aDialogCreate, GUI_COUNTOF(_aDialogCreate), _cbDialog, WM_HBKWIN, 0, 0);
	hWin_x =hWin;//
	///测试 flash by yan
	
	
	
	//测试flash by yan
	  while (1) {
    #ifdef WIN32
      GUI_Delay(10);
    #endif
				
				if(Staues[0]==1)//开始的标志位 
				{
						_AddValues();///显示波形并将采样值给全局变量
				
				}
				//GPIO_ResetBits(GPIOB,GPIO_Pin_3);
				////采集显示 在送料的时候 不采集
				if (Staues[16]==1) {
							adc_result_x=adc_all_onley*3.3/4096;
								//	if(fabs(adc_result_x-temp_compare)>=0.005)//设置显示门限值，超过一个值显示
									//{
									display1=Float_to_string(adc_result_x);
									hItem = WM_GetDialogItem(hWin, ID_TEXT_display);
									TEXT_SetText(hItem,display1);
									//\\\}
							temp_compare=adc_result_x;

					}
					
						//显示单次采集延时 循环并显示,Staues[10]定时器计算时间标志最长是1分钟
						
			
		
			///清洗送料
				if(Staues[18]==1)
					{
						//GPIO_SetBits(GPIOB,GPIO_Pin_3); //off enanble 将搅拌电机关闭
						TIM_Cmd(TIM3,DISABLE);//关闭电机搅拌
							//TIM2_PWM_Init(899,1000);	//旧版清洗用GPIO pb3 口 pwm控制
							TIM4_PWM_Init(2899,1000);	//新版清洗用GPIO pb6 口 pwm控制
						//分频 ,PWM PWM频率 =72000/2900/1000=? 2016-3-10 yan
						if(Staues[0]==1)//由于时间的原因 所以可以看出逐渐增加的效果by yan 2016-1-25
							led0pwmval=led0pwmval-200;
						else if(Staues[0]==0)
							led0pwmval=led0pwmval-1;
						 
						if(led0pwmval<0)
						{
							led0pwmval=0;
						}
							//TIM_SetCompare1(TIM4,0);
							//TIM_SetCompare2(TIM4,0);								
							TIM_SetCompare1(TIM4,led0pwmval);
							//GPIO_ResetBits(GPIOB,GPIO_Pin_6);//拉低了
					}
				else if(Staues[18]==0)
				{
					//GPIO_ResetBits(GPIOB,GPIO_Pin_6);
					led0pwmval=3000;//逐渐增加http://www.openedv.com/posts/list/52608.htm
					TIM_SetCompare1(TIM4,led0pwmval);
					//GPIO_SetBits(GPIOB,GPIO_Pin_6);//
					//	TIM_Cmd(TIM3,ENABLE);//关闭电机搅拌
				//	TIM_SetCompare2(TIM4,led0pwmval);	
					//TIM_Cmd(TIM4, DISABLE);  //使能TIM4
					 //TIM_SetCompare1(TIM4,led0pwmval);
						
				}
					
	
    GUI_Exec();
							
  }
}

// USER START (Optionally insert additional public code)
// USER END
//增加了 单次时间采集 一个具体的数值，还有几个问题，校准，要三次：一次是缓冲液，二次是基准样，三次还是基准样,修改了
//波形显示，步进电机换了gpio口，定时器 采用了Tim5 tim4要作为pwm控制
/*************************** End of file ****************************/
